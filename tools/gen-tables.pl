#!/usr/bin/perl
#
# libnogg: a decoder library for Ogg Vorbis streams
# Copyright (c) 2014-2023 Andrew Church <achurch@achurch.org>
#
# This software may be copied and redistributed under certain conditions;
# see the file "COPYING" in the source code distribution for details.
# NO WARRANTY is provided with this software.
#

#
# This script generates the lookup tables used when the library is built
# with the USE_LOOKUP_TABLES option.  The output of the script should be
# written to the file "src/decode/tables.c".
#

use strict;
use warnings;
use constant PI => 3.141592653589793238;


sub bit_reverse($) {
    my ($n) = @_;
    $n = (($n & 0xAAAAAAAA) >>  1) | (($n & 0x55555555) << 1);
    $n = (($n & 0xCCCCCCCC) >>  2) | (($n & 0x33333333) << 2);
    $n = (($n & 0xF0F0F0F0) >>  4) | (($n & 0x0F0F0F0F) << 4);
    $n = (($n & 0xFF00FF00) >>  8) | (($n & 0x00FF00FF) << 8);
    return ($n >> 16) | ($n << 16);
}


print <<EOT;
/* This file is automatically generated. */
#include "src/decode/tables.h"

#ifdef USE_LOOKUP_TABLES
EOT


# Generate the IMDCT tables A, B, and C.

print "\n";

foreach my $bits (6..13) {
    my $blocksize = 1 << $bits;

    print "ALIGN(32) static const float table_A_${bits}[] = {\n";
    for (my $i = 0; $i < $blocksize/2; $i += 2) {
        printf " %.8e, %.8e,%s",
            cos($i*(2*PI/$blocksize)),
            -sin($i*(2*PI/$blocksize)),
            $i%4 == 2 ? "\n" : "";
    }
    print "};\n";

    print "ALIGN(32) static const float table_B_${bits}[] = {\n";
    for (my $i = 0; $i < $blocksize/2; $i += 2) {
        printf " %.8e, %.8e,%s",
            cos(($i+1)*(0.5*PI/$blocksize)) * 0.5,
            sin(($i+1)*(0.5*PI/$blocksize)) * 0.5,
            $i%4 == 2 ? "\n" : "";
    }
    print "};\n";

    print "ALIGN(32) static const float table_C_${bits}[] = {\n";
    for (my $i = 0; $i < $blocksize/4; $i += 2) {
        printf " %.8e, %.8e,%s",
            cos(($i+1)*(2*PI/$blocksize)),
            -sin(($i+1)*(2*PI/$blocksize)),
            $i%4 == 2 ? "\n" : "";
    }
    print "};\n";
}

foreach my $table ("A","B","C") {
    printf "const float * const table_%s[8] = {%s};\n", $table,
        join(", ", map {"table_${table}_$_"} (6..13));
}


# Generate the bit-reverse lookup tables.

print "\n";

foreach my $bits (6..13) {
    my $blocksize = 1 << $bits;
    print "ALIGN(32) static const uint16_t table_bitrev_${bits}[] = {\n";
    for (my $i = 0; $i < $blocksize/8; $i++) {
        printf " 0x%04X,%s",
            (&bit_reverse($i) >> (32-$bits+3)) << 2,
            $i%8 == 7 ? "\n" : "";
    }
    print "};\n";
}

printf "const uint16_t * const table_bitrev[8] = {%s};\n",
    join(", ", map {"table_bitrev_$_"} (6..13));


# Generate the window weight lookup tables.

print "\n";

foreach my $bits (6..13) {
    my $blocksize = 1 << $bits;
    print "ALIGN(32) static const float table_weights_${bits}[] = {\n";
    for (my $i = 0; $i < $blocksize/2; $i++) {
        my $x = sin(($i+0.5)*PI/$blocksize);
        printf " %.8e,%s",
            sin(0.5*PI*($x*$x)),
            $i%4 == 3 ? "\n" : "";
    }
    print "};\n";
}

printf "const float * const table_weights[8] = {%s};\n",
    join(", ", map {"table_weights_$_"} (6..13));


print "\n#endif  // USE_LOOKUP_TABLES\n";
